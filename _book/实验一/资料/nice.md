# 预备知识

我们可以通过ps -l看到当前正在运行的进程的详细信息:

![](https://i.loli.net/2019/04/03/5ca47ee67e677.png)

其中,

* F：表示进程旗标，标识进程所拥有的权限，当我切换到root的时候为4表示拥有root权限，为1仅有fork()权限
* S：表示进程当前的状态
  * R：当前正在运行(RUNNING)
  * S：睡眠(SLEEP)
  * D：不可中断
  * T：停止(STOP)
  * Z：僵尸进程(ZOMBIE)
* UID：拥有该进程用户的用户ID
* PID：进程号
* PPID：该进程父进程的进程好
* C：CPU是用百分比
* PRI：优先级
* NI：nice值
* ADDR/SZ/WCHAN：都与内存有关
* TTY：登陆者的终端，和远程登陆脱不开干系
* TIME：占用CPU时间
* CMD：造成此进程的命令



我们把主要进程分为两种：

​	**1.I/O消耗型进程；**

​	**2.处理器消耗型进程**

当然也有既是I/O消耗型也是处理器消耗型的进程。

I/O消耗型进程如字面意思一样，轮到它的时候会把大部分时间消耗在I/O请求和等待I/O上，真正使用CPU的时间很少，处理器消耗性进程会把大部分时间用在使用CPU进行计算之类的，如果给这两种继承分配的时间片长度相等，就会体现出不公平。

同时我们想给处理器消耗型的进程多一些处理器时间，而给I/O消耗性进程少一些处理器时间，于是linux采取的不是简单的时间片调度算法，而是改进的优先级调度算法CFS。

**Linux系统是抢占式的**，什么概念呢，系统当前运行一个进程，但这个时候一个具有更高优先级的进程突然得到某种资源进入了就绪状态，然后他就来到cpu面前一脚踢开正在运行的进程（你奏凯，我先来）就抢夺了与CPU共度的美好时光。

**CFS直接分配的不是时间片，而是CPU使用比，这个比例会受到nice值得影响，然后你懂，nice值低比重就高，nice高比重就低**。

------

**Q：**Linux使用的CFS调度器，决定抢占时机的就是上面说的CPU使用比，注意！**反而CPU使用比低的新进程会立刻投入运行，CPU使用比高的新进程会延迟运行**，为什么呢？

**A：**因为**CFS的出发点**基于一个非常简单的概念：**进程调度的效果应如同系统具备一个理想中的完美多任务处理器。在这种系统中每个进程将能获得1/n的处理器时间**。就是说每个进程**真正使用cpu的时间**是一样的，包括I/O消耗型和处理器消耗型，以达到真正的公平，这就解释了刚才的问题，CPU使用比低的占用时间会不可避免的少于占用比高的进程，那我们只好让这个进程具有抢占能力，一就绪就可以抢占，这样子“**看起来**CPU使用比高了”（其实没变）“**看起来**CPU占用时间也和其他进程一样多了”（其实不多）。**抢占能力高了，交互性相对而言就好了**，你看你人打个游戏，交互性就得高，不然你按个键放个技能电脑不给你处理，你就坑队友了。

+ **Linux对普通进程采用的是完全公平调度算法（CFS）**

+ Linux的进程调度并未使用直接均分时间片的方式，而是对优先级进行了改进，**采用了两种不同的优先级范围，一种是nice值，范围是-20到+19，越大的nice值意味着更低的优先级，低nice值的进程会获得更多的处理器时间（按比例获得），第二种范围是实时优先级，其值是可配置的，默认情况下它的变化范围是从0到99，与nice值意义相反，越高的实时优先级数值意味着进程优先级越高，任何实时进程的优先级都高于普通进程**
  + **PS：nice值还会不断对old优先级进行更改，当然也可以设置nice的值，nice值给负值必须要用root**
+ **nice值不是优先级，但会影响优先级 PRI(new)=PRI(old)+nice**

* **时间片过长会导致人机交互欠佳，而时间片过短会导致大量的处理器时间浪费在进程的切换上**，而且I/O消耗型进程和处理器消耗型进程之间的处理器时间的不公平之处也显现出来了

* CFS并没有直接分配时间片到进程，而是将处理器的使用比划分给了进程，这个比例还会受到nice值的影响
* CFS的做法是允许每个进程运行一段时间，循环轮转，**选择运行最少的进程作为写一个运行进程**，所以根据nice值的含义-占用处理器的百分比，来根据系统中全部可运行进程总数来根据所占比例的“时间片”运行
* **linux设计总是想分配给N个进程每个进程同样多的处理器运行时间**，当N趋于无穷大的时候，按理说是**可以分配给无限小的时间周期**，但是这么做会很糟糕，我们也无法分配无限小的时间周期，**虽然越小的时间周期可以带来更好的交互性，但还是带来不可接受的切换消耗**，所以引入了一个**目标延迟**，来模拟无限小调度周期的近似值，现在假设目标延迟就是20ms，用它除以所有当前可以运行的进程数目就可以得到每个进程获得的时间片长度，当进程数无限大时候，每个进程分配的时间就趋于无限小，很好，进程切换又爆炸了，那么如果把最小值设为为1ms呢，进程数目再多我也保证每个进程在被强占之前获得1ms的运行时间，那么这个1ms就被称为**最小粒度**

**然而最后影响CFS调度器调度进程的并不是优先级的nice值**，因为CFS说了，我要让每个进程获得的处理器时间都是一样的（虽然不可能），**所以有一个vruntime的值表示进程运行的虚拟时间（就是在处理器上跑的时间累加和）**，**这个vruntime值越小，说明该进程应该被优先执行（或者获得更多的处理器时间片）**，因为他饿了。。。

**一次调度间隔的虚拟运行时间=实际运行时间\*（NICE_0_LOAD/权重）这就是nice值和vruntime之间的关系，其中，NICE_0_LOAD是nice为0时的权重**

**当nice值为0证明虚拟运行时间=实际运行时间**